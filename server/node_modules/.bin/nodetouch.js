#!/usr/bin/env node
'use strict';

var touch = require("../index.js");

var usage = function usage(code) {
  console[code ? 'error' : 'log']('usage:\n' + 'touch [-acfm] [-r file] [-t [[CC]YY]MMDDhhmm[.SS]] file ...');
  process.exit(code);
};

var singleFlags = {
  a: 'atime',
  m: 'mtime',
  c: 'nocreate',
  f: 'force'
};

var singleOpts = {
  r: 'ref',
  t: 'time'
};

var files = [];
var args = process.argv.slice(2);
var options = {};
for (var i = 0; i < args.length; i++) {
  var arg = args[i];
  if (!arg.match(/^-/)) {
    files.push(arg);
    continue;
  }

  // expand shorthands
  if (arg.charAt(1) !== '-') {
    var expand = [];
    for (var f = 1; f < arg.length; f++) {
      var fc = arg.charAt(f);
      var sf = singleFlags[fc];
      var so = singleOpts[fc];
      if (sf) expand.push('--' + sf);else if (so) {
        var soslice = arg.slice(f + 1);
        var soval = soslice.charAt(0) === '=' ? soslice : '=' + soslice;
        expand.push('--' + so + soval);
        f = arg.length;
      } else if (arg !== '-' + fc) expand.push('-' + fc);
    }
    if (expand.length) {
      args.splice.apply(args, [i, 1].concat(expand));
      i--;
      continue;
    }
  }

  var argsplit = arg.split('=');
  var key = argsplit.shift().replace(/^\-\-/, '');
  var val = argsplit.length ? argsplit.join('=') : null;

  switch (key) {
    case 'time':
      var timestr = val || args[++i];
      // [-t [[CC]YY]MMDDhhmm[.SS]]
      var parsedtime = timestr.match(/^(([0-9]{2})?([0-9]{2}))?([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})(\.([0-9]{2}))?$/);
      if (!parsedtime) {
        console.error('touch: out of range or illegal ' + 'time specification: ' + '[[CC]YY]MMDDhhmm[.SS]');
        process.exit(1);
      } else {
        var y = +parsedtime[1];
        var year = parsedtime[2] ? y : y <= 68 ? 2000 + y : 1900 + y;

        var MM = +parsedtime[4] - 1;
        var dd = +parsedtime[5];
        var hh = +parsedtime[6];
        var mm = +parsedtime[7];
        var ss = +parsedtime[8];

        options.time = new Date(Date.UTC(year, MM, dd, hh, mm, ss));
      }
      continue;

    case 'ref':
      options.ref = val || args[++i];
      continue;

    case 'mtime':
    case 'nocreate':
    case 'atime':
    case 'force':
      options[key] = true;
      continue;

    default:
      console.error('touch: illegal option -- ' + arg);
      usage(1);
  }
}

if (!files.length) usage();

process.exitCode = 0;
Promise.all(files.map(function (f) {
  return touch(f, options);
})).catch(function (er) {
  return process.exitCode = 1;
});